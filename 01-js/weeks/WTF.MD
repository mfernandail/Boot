# ğŸª Los "WTF" de JavaScript Explicados

## 1. ğŸ”¢ typeof null === "object"

```js
typeof null // "object" â† Â¿QUÃ‰?
typeof undefined // "undefined" â† Esto sÃ­ tiene sentido
```

### Â¿Por quÃ©?

BUG HISTÃ“RICO desde 1995 que nunca se corrigiÃ³ por compatibilidad.
Historia:

- En la primera versiÃ³n de JavaScript, los valores se representaban con etiquetas de tipo
- Los objetos tenÃ­an etiqueta 000
- null se representaba como puntero NULL (todo ceros: 0x00)
- El motor interpretaba esos ceros como "objeto"
- Brendan Eich (creador de JS) lo reconociÃ³ como error
- Hubo propuesta de corregirlo en ES6 pero romperÃ­a millones de sitios web

## 2. ğŸ­ [] + [] = "" y [] + {} = "[object Object]"

```js
[] + []        // "" (string vacÃ­o)
[] + {}        // "[object Object]"
{} + []        // 0
{} + {}        // NaN (o "[object Object][object Object]" segÃºn contexto)
({} + []) // "[object Object]"
({} + {})      // "[object Object][object Object]"

// [] + []
// 1. JavaScript intenta sumar
// 2. No puede, entonces convierte a primitivos
// 3. [].toString() = ""
// 4. "" + "" = ""

// [] + {}
// 1. [].toString() = ""
// 2. {}.toString() = "[object Object]"
// 3. "" + "[object Object]" = "[object Object]"

// {} + []
// 1. El {} se interpreta como BLOQUE DE CÃ“DIGO vacÃ­o, al estar al inicio de la lÃ­nea, diferente seria si es que estuviera entre parÃ©ntesis: ({} + [])
// 2. Queda: +[]
// 3. +[] convierte a nÃºmero
// 4. Number([]) = 0

```

### Â¿Por quÃ©?

- El operador + en JavaScript tiene dos funciones: suma numÃ©rica y concatenaciÃ³n de strings.
- Cuando se usa con arrays u objetos, JavaScript intenta convertirlos a strings.
- Un array vacÃ­o `[]` se convierte en una cadena vacÃ­a `""`.
- Un objeto vacÃ­o `{}` se convierte en la cadena `"[object Object]"`.
- Por lo tanto:
  - `[] + []` se convierte en `"" + ""`, que es `""`.
  - `[] + {}` se convierte en `"" + "[object Object]"`, que es `"[object Object]"`.
  - `{ } + []` se interpreta como un bloque de cÃ³digo vacÃ­o seguido de una expresiÃ³n `+ []`, que se convierte en `0`.
  - Para evitar confusiones, es recomendable usar parÃ©ntesis para dejar claro el orden de las operaciones, por ejemplo: `([]) + ({})` o `({}) + ([])`.

## 3. ğŸ”„ 0.1 + 0.2 !== 0.3

```js
0.1 + 0.2 // 0.30000000000000004
0.1 + 0.2 === 0.3 // false

// Pero...
0.1 + 0.2 === 0.30000000000000004 // true
```

### Â¿Por quÃ©?

**NO es un bug de JavaScript**, es cÃ³mo funcionan los nÃºmeros en **todos** los lenguajes.

**ExplicaciÃ³n tÃ©cnica:**

- JavaScript usa formato IEEE 754 (punto flotante de 64 bits)
- Algunos decimales no se pueden representar exactamente en binario
- Como 1/3 = 0.333... en decimal, algunos nÃºmeros son infinitos en binario

**AnalogÃ­a:**

```
Decimal: 1/3 = 0.333333... (infinito)
Binario: 0.1 = 0.0001100110011... (infinito)
```

## 4. ğŸ§® Math.max() < Math.min()

```js
Math.max() // -Infinity
Math.min() // Infinity

Math.max() < Math.min() // true â† Â¿Â¡QUÃ‰!?
```

### Â¿Por quÃ©?

- `Math.max()` sin argumentos devuelve `-Infinity` porque no hay nÃºmeros para comparar, y cualquier nÃºmero es mayor que `-Infinity`.
- `Math.min()` sin argumentos devuelve `Infinity` porque no hay nÃºmeros para comparar, y cualquier nÃºmero es menor que `Infinity`.
- Por lo tanto, `Math.max()` (que es `-Infinity`) es efectivamente menor que `Math.min()` (que es `Infinity`), haciendo que la expresiÃ³n `Math.max() < Math.min()` sea `true`.

## âœ… Reglas de Oro:

1. Siempre usa === nunca == (excepto == null para null/undefined)
2. Siempre usa let/const, nunca var
3. Array.isArray() para verificar arrays
4. Siempre especifica la base en parseInt()
5. No uses delete con arrays, usa splice o filter
6. Siempre usa comparador con sort() para nÃºmeros
7. Arrow functions para preservar this
8. Number.isNaN() en vez de isNaN()
9. Array.from() o spread en vez de Array(n)
10. Usa siempre parÃ©ntesis para evitar ambigÃ¼edades con objetos y arrays en expresiones
